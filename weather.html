<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Weather — Upgraded</title>
<style>
  :root{
    --bg:#e6f2ff; --card:#fff; --accent:#0366d6; --muted:#556;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    min-height:100vh; display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg,var(--bg), #f8fcff); color:var(--muted); padding:24px;
  }
  .card{
    width:900px; max-width:95vw; background:var(--card); border-radius:12px; padding:18px;
    box-shadow:0 10px 30px rgba(2,6,23,0.12);
  }
  .top {
    display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;
  }
  .controls { display:flex; gap:8px; align-items:center; }
  input[type="text"]{ padding:8px 10px; border-radius:8px; border:1px solid #d7e7ff; min-width:220px; }
  button{ padding:8px 12px; border-radius:8px; border:none; cursor:pointer; background:var(--accent); color:white; }
  .muted{ color:#8b98a8; font-size:14px }

  .main {
    display:grid; grid-template-columns: 1fr 320px; gap:18px; margin-top:18px;
  }
  /* Current weather */
  .current {
    padding:16px; background:linear-gradient(180deg,#fff,#f6fbff); border-radius:10px;
    display:flex; gap:16px; align-items:center;
  }
  .current .left { display:flex; gap:12px; align-items:center; }
  .temp { font-size:48px; font-weight:700; color:var(--accent); }
  .desc { font-size:18px; text-transform:capitalize; }
  .weather-icon { width:96px; height:96px; }

  /* forecast */
  .forecast {
    display:flex; gap:8px; align-items:center; justify-content:space-between; margin-top:12px;
  }
  .day {
    background:#fff; border-radius:8px; padding:10px; text-align:center; min-width:110px;
    box-shadow:0 4px 12px rgba(2,6,23,0.06);
  }
  .small { font-size:13px; color:#6c7a89; }

  /* right column (details + extras) */
  .side {
    display:flex; flex-direction:column; gap:12px;
  }
  .card-block { background:#fff; padding:12px; border-radius:8px; box-shadow:0 4px 12px rgba(2,6,23,0.05); }
  .row { display:flex; justify-content:space-between; margin-top:6px; font-weight:600; }

  @media (max-width:880px){
    .main { grid-template-columns: 1fr; }
    .side { order:2 }
  }
</style>
</head>
<body>
  <div class="card">
    <div class="top">
      <h2>Weather App</h2>

      <div class="controls">
        <input id="cityInput" type="text" placeholder="Enter city (e.g. Chennai)">
        <button id="searchBtn">Search</button>
        <button id="locBtn" title="Use current location">Use my location</button>
        <label class="muted" style="display:flex;align-items:center;gap:8px;margin-left:6px">
          Units:
          <select id="units">
            <option value="metric">°C</option>
            <option value="imperial">°F</option>
          </select>
        </label>
      </div>
    </div>

    <div class="main">
      <div>
        <div id="currentCard" class="current" aria-live="polite">
          <div class="left">
            <img id="icon" class="weather-icon" src="" alt="" />
            <div>
              <div id="cityName" style="font-weight:700;font-size:20px">—</div>
              <div id="weatherDesc" class="desc">—</div>
            </div>
          </div>

          <div>
            <div class="temp" id="temp">--°</div>
            <div class="small" id="feels">Feels like: --°</div>
            <div class="small" id="humidity">Humidity: --%</div>
            <div class="small" id="wind">Wind: --</div>
          </div>
        </div>

        <div class="card-block" id="forecastBlock" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">5-Day Forecast</div>
            <div class="muted small" id="forecastHint">Daily summary</div>
          </div>
          <div id="forecast" class="forecast" style="margin-top:10px">
            <!-- days will be injected here -->
          </div>
        </div>
      </div>

      <div class="side">
        <div class="card-block">
          <div style="font-weight:700">Details</div>
          <div class="row"><span class="small">Pressure</span><span id="pressure">-- hPa</span></div>
          <div class="row"><span class="small">Visibility</span><span id="visibility">--</span></div>
          <div class="row"><span class="small">Sunrise</span><span id="sunrise">--</span></div>
          <div class="row"><span class="small">Sunset</span><span id="sunset">--</span></div>
        </div>

        <div class="card-block">
          <div style="font-weight:700">About</div>
          <p class="small" style="margin-top:8px">This demo uses OpenWeatherMap's free APIs (current weather + 5-day forecast). Replace the API key in the script to make requests.</p>
        </div>

      </div>
    </div>
  </div>

<script>
/* ========= CONFIG ========= */
const API_KEY = "5b54a68a72d590b974726c7bb3107a6f"; // <-- REPLACE with your OpenWeatherMap key
const ICON_URL = (icon) => `https://openweathermap.org/img/wn/${icon}@2x.png`;

/* ========= HELPERS ========= */
function el(id){ return document.getElementById(id); }
function fmtTimeFromUnix(unix, timezoneOffset=0){
  // unix is in seconds, timezoneOffset in seconds (from API). Return HH:MM
  const d = new Date((unix + timezoneOffset) * 1000);
  return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
}
function safeText(t){ return t ?? '--'; }

/* ========= UI refs ========= */
const cityInput = el('cityInput');
const searchBtn = el('searchBtn');
const locBtn = el('locBtn');
const unitsSelect = el('units');

const iconImg = el('icon');
const cityName = el('cityName');
const weatherDesc = el('weatherDesc');
const tempEl = el('temp');
const feelsEl = el('feels');
const humidityEl = el('humidity');
const windEl = el('wind');

const pressureEl = el('pressure');
const visibilityEl = el('visibility');
const sunriseEl = el('sunrise');
const sunsetEl = el('sunset');

const forecastContainer = el('forecast');
const forecastHint = el('forecastHint');

/* ========= STATE ========= */
let lastCity = localStorage.getItem('weather_city') || '';
let lastUnits = localStorage.getItem('weather_units') || 'metric';
unitsSelect.value = lastUnits;
if(lastCity) cityInput.value = lastCity;

/* ========= NETWORK ========= */

/*
 We use two endpoints:
 1) Current weather by city:  api.openweathermap.org/data/2.5/weather?q={city}&units={units}&appid={API_KEY}
 2) 5-day forecast by city: api.openweathermap.org/data/2.5/forecast?q={city}&units={units}&appid={API_KEY}
 Alternatively when we have lat/lon we call same endpoints with lat & lon.
*/

// Fetch current + 5-day by city or coords
async function fetchWeather({city=null, lat=null, lon=null, units='metric'}) {
  try {
    let base = 'https://api.openweathermap.org/data/2.5/';
    let currentUrl, forecastUrl;

    if (city) {
      currentUrl = `${base}weather?q=${encodeURIComponent(city)}&units=${units}&appid=${API_KEY}`;
      forecastUrl = `${base}forecast?q=${encodeURIComponent(city)}&units=${units}&appid=${API_KEY}`;
    } else if (lat !== null && lon !== null) {
      currentUrl = `${base}weather?lat=${lat}&lon=${lon}&units=${units}&appid=${API_KEY}`;
      forecastUrl = `${base}forecast?lat=${lat}&lon=${lon}&units=${units}&appid=${API_KEY}`;
    } else {
      throw new Error('City or coordinates required');
    }

    // fetch both in parallel
    const [currResp, fcResp] = await Promise.all([fetch(currentUrl), fetch(forecastUrl)]);
    if (!currResp.ok) throw new Error(`Current weather: ${currResp.statusText}`);
    if (!fcResp.ok) throw new Error(`Forecast: ${fcResp.statusText}`);

    const current = await currResp.json();
    const forecast = await fcResp.json();
    return { current, forecast };
  } catch (err) {
    throw err;
  }
}

/* ========= UI UPDATES ========= */
function updateCurrentUI(data, units){
  const tzOffset = data.timezone || 0; // seconds
  iconImg.src = ICON_URL(data.weather[0].icon);
  iconImg.alt = data.weather[0].description || '';
  cityName.textContent = `${data.name}, ${data.sys.country}`;
  weatherDesc.textContent = data.weather[0].description;
  tempEl.textContent = `${Math.round(data.main.temp)}°${units==='metric'?'C':'F'}`;
  feelsEl.textContent = `Feels like: ${Math.round(data.main.feels_like)}°`;
  humidityEl.textContent = `Humidity: ${data.main.humidity}%`;
  windEl.textContent = `Wind: ${data.wind.speed} ${units==='metric' ? 'm/s' : 'mph'}`;

  pressureEl.textContent = `${data.main.pressure} hPa`;
  visibilityEl.textContent = `${(data.visibility/1000).toFixed(1)} km`;
  sunriseEl.textContent = fmtTimeFromUnix(data.sys.sunrise, tzOffset);
  sunsetEl.textContent = fmtTimeFromUnix(data.sys.sunset, tzOffset);
}

function buildForecastUI(forecastData, units){
  /* forecastData.list contains 3-hour entries for 5 days.
     We want a single daily summary for the next 5 days (including today optionally).
     Approach: group by date (YYYY-MM-DD) and pick the entry around 12:00 if available, else middle entry.
  */
  const tzOffset = forecastData.city && forecastData.city.timezone ? forecastData.city.timezone : 0;
  const groups = {};
  forecastData.list.forEach(item => {
    const date = new Date((item.dt + tzOffset)*1000);
    // use local date string in ISO to group
    const dayKey = date.toISOString().slice(0,10);
    if (!groups[dayKey]) groups[dayKey] = [];
    groups[dayKey].push(item);
  });

  const days = Object.keys(groups).slice(0,5); // take first 5 keys
  forecastContainer.innerHTML = '';
  days.forEach(dayKey => {
    const items = groups[dayKey];
    // try to find hour 12:00, else pick mid
    let pick = items.find(i => new Date((i.dt+tzOffset)*1000).getUTCHours()===12) || items[Math.floor(items.length/2)];
    const dateObj = new Date((pick.dt + tzOffset)*1000);
    const weekday = dateObj.toLocaleDateString([], { weekday: 'short' }); // Mon, Tue
    const icon = pick.weather[0].icon;
    const desc = pick.weather[0].description;
    const tempMin = Math.round(Math.min(...items.map(x => x.main.temp_min)));
    const tempMax = Math.round(Math.max(...items.map(x => x.main.temp_max)));

    const dayEl = document.createElement('div');
    dayEl.className = 'day';
    dayEl.innerHTML = `
      <div class="small">${weekday}</div>
      <img src="${ICON_URL(icon)}" alt="${desc}" style="width:64px;height:64px">
      <div style="font-weight:700">${tempMax}° / ${tempMin}°</div>
      <div class="small" style="text-transform:capitalize">${desc}</div>
    `;
    forecastContainer.appendChild(dayEl);
  });

  forecastHint.textContent = `Units: ${units === 'metric' ? '°C' : '°F'}`;
}

/* ========= ACTIONS ========= */

async function doSearchCity(city, units){
  try {
    showLoading(true);
    const { current, forecast } = await fetchWeather({ city, units });
    updateCurrentUI(current, units);
    buildForecastUI(forecast, units);
    // save last
    localStorage.setItem('weather_city', city);
    localStorage.setItem('weather_units', units);
  } catch (err) {
    alert(`Could not get weather: ${err.message}`);
    console.error(err);
  } finally {
    showLoading(false);
  }
}

async function doSearchCoords(lat, lon, units){
  try {
    showLoading(true);
    const { current, forecast } = await fetchWeather({ lat, lon, units });
    updateCurrentUI(current, units);
    buildForecastUI(forecast, units);
    // save last coords? we save as city name if available
    if (current && current.name) {
      localStorage.setItem('weather_city', current.name);
    }
    localStorage.setItem('weather_units', units);
  } catch (err) {
    alert(`Could not get weather: ${err.message}`);
    console.error(err);
  } finally {
    showLoading(false);
  }
}

/* ========= UX helpers ========= */
function showLoading(loading){
  if (loading) {
    searchBtn.disabled = true;
    searchBtn.textContent = 'Loading...';
  } else {
    searchBtn.disabled = false;
    searchBtn.textContent = 'Search';
  }
}

/* ========= EVENTS ========= */
searchBtn.addEventListener('click', () => {
  const city = cityInput.value.trim();
  const units = unitsSelect.value;
  if (!city) return alert('Please enter a city name (e.g., "Paris")');
  doSearchCity(city, units);
});

cityInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') searchBtn.click();
});

locBtn.addEventListener('click', () => {
  if (!navigator.geolocation) return alert('Geolocation not supported by this browser');
  navigator.geolocation.getCurrentPosition(pos => {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    doSearchCoords(lat, lon, unitsSelect.value);
  }, err => {
    alert('Could not get location: ' + err.message);
  }, { enableHighAccuracy: true, timeout: 10000 });
});

unitsSelect.addEventListener('change', () => {
  const units = unitsSelect.value;
  localStorage.setItem('weather_units', units);
  // re-run search with last city if present
  const city = cityInput.value.trim() || localStorage.getItem('weather_city');
  if (city) doSearchCity(city, units);
});

/* ========= INITIAL LOAD ========= */
(async function init(){
  const units = localStorage.getItem('weather_units') || 'metric';
  unitsSelect.value = units;
  const savedCity = localStorage.getItem('weather_city') || '';
  if (savedCity) {
    cityInput.value = savedCity;
    try { await doSearchCity(savedCity, units); } catch(e){ console.warn(e); }
  }
})();
</script>
</body>
</html>
